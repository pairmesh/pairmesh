// Copyright 2022 PairMesh, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by MockGen. DO NOT EDIT.
// Source: ./session_transporter.go

// Package relay is a generated GoMock package.
package relay

import (
	context "context"
	reflect "reflect"

	noise "github.com/flynn/noise"
	gomock "github.com/golang/mock/gomock"
	"github.com/pairmesh/pairmesh/internal/codec"
)

// MockSessionTransporter is a mock of SessionTransporter interface.
type MockSessionTransporter struct {
	ctrl     *gomock.Controller
	recorder *MockSessionTransporterMockRecorder
}

// MockSessionTransporterMockRecorder is the mock recorder for MockSessionTransporter.
type MockSessionTransporterMockRecorder struct {
	mock *MockSessionTransporter
}

// NewMockSessionTransporter creates a new mock instance.
func NewMockSessionTransporter(ctrl *gomock.Controller) *MockSessionTransporter {
	mock := &MockSessionTransporter{ctrl: ctrl}
	mock.recorder = &MockSessionTransporterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionTransporter) EXPECT() *MockSessionTransporterMockRecorder {
	return m.recorder
}

// Cipher mocks base method.
func (m *MockSessionTransporter) Cipher() noise.Cipher {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cipher")
	ret0, _ := ret[0].(noise.Cipher)
	return ret0
}

// Cipher indicates an expected call of Cipher.
func (mr *MockSessionTransporterMockRecorder) Cipher() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cipher", reflect.TypeOf((*MockSessionTransporter)(nil).Cipher))
}

// Close mocks base method.
func (m *MockSessionTransporter) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockSessionTransporterMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSessionTransporter)(nil).Close))
}

// PublicKey mocks base method.
func (m *MockSessionTransporter) PublicKey() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublicKey")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// PublicKey indicates an expected call of PublicKey.
func (mr *MockSessionTransporterMockRecorder) PublicKey() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublicKey", reflect.TypeOf((*MockSessionTransporter)(nil).PublicKey))
}

// Read mocks base method.
func (m *MockSessionTransporter) Read(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Read", ctx)
}

// Read indicates an expected call of Read.
func (mr *MockSessionTransporterMockRecorder) Read(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockSessionTransporter)(nil).Read), ctx)
}

// ReadQueue mocks base method.
func (m *MockSessionTransporter) ReadQueue() <-chan codec.RawPacket {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadQueue")
	ret0, _ := ret[0].(<-chan codec.RawPacket)
	return ret0
}

// ReadQueue indicates an expected call of ReadQueue.
func (mr *MockSessionTransporterMockRecorder) ReadQueue() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadQueue", reflect.TypeOf((*MockSessionTransporter)(nil).ReadQueue))
}

// SetCipher mocks base method.
func (m *MockSessionTransporter) SetCipher(cipher noise.Cipher) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCipher", cipher)
}

// SetCipher indicates an expected call of SetCipher.
func (mr *MockSessionTransporterMockRecorder) SetCipher(cipher interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCipher", reflect.TypeOf((*MockSessionTransporter)(nil).SetCipher), cipher)
}

// SetPublicKey mocks base method.
func (m *MockSessionTransporter) SetPublicKey(pk []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPublicKey", pk)
}

// SetPublicKey indicates an expected call of SetPublicKey.
func (mr *MockSessionTransporterMockRecorder) SetPublicKey(pk interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPublicKey", reflect.TypeOf((*MockSessionTransporter)(nil).SetPublicKey), pk)
}

// Write mocks base method.
func (m *MockSessionTransporter) Write(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Write", ctx)
}

// Write indicates an expected call of Write.
func (mr *MockSessionTransporterMockRecorder) Write(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockSessionTransporter)(nil).Write), ctx)
}

// WriteQueue mocks base method.
func (m *MockSessionTransporter) WriteQueue() chan<- Packet {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteQueue")
	ret0, _ := ret[0].(chan<- Packet)
	return ret0
}

// WriteQueue indicates an expected call of WriteQueue.
func (mr *MockSessionTransporterMockRecorder) WriteQueue() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteQueue", reflect.TypeOf((*MockSessionTransporter)(nil).WriteQueue))
}
